<html>
    <head>
      <script type="text/javascript" src="settings.js" />
      <script type="text/javascript" src="channels.js" />
      <script type="text/javascript" src="channels1.js" />
      <script type="text/javascript" src="channels5.js" />
      <script type="text/javascript" src="channels6.js" />
      <script type="text/javascript" src="channels9.js" />
    </head>
<script language="Javascript">

//
// Javascript VDR client for Motorola VIP19x0 & VIP19x3
//
// Martin Voerman Rekordc@gmail.com
//
// TODO 
//
// 
// make VDR connection
// 	get/set/create/edit timers
// 	make/view recordings
//
//
//

var Version = "0.10	2013/01/08"

for (var i = minChan[0];  i < (maxChan[0]+1); i++) { EPG[0][4][i] = "";EPG[1][4][i] = "";EPG[0][5][i] = "";EPG[1][5][i] = "";EPG[0][7][i] = "";EPG[1][7][i] = ""; }
for (var i = minChan[1];  i < (maxChan[1]+1); i++) { EPG[0][4][i] = "";EPG[1][4][i] = "";EPG[0][5][i] = "";EPG[1][5][i] = "";EPG[0][7][i] = "";EPG[1][7][i] = ""; }
for (var i = minChan[5];  i < (maxChan[5]+1); i++) { EPG[0][4][i] = "";EPG[1][4][i] = "";EPG[0][5][i] = "";EPG[1][5][i] = "";EPG[0][7][i] = "";EPG[1][7][i] = ""; }
for (var i = minChan[6];  i < (maxChan[6]+1); i++) { EPG[0][4][i] = "";EPG[1][4][i] = "";EPG[0][5][i] = "";EPG[1][5][i] = "";EPG[0][7][i] = "";EPG[1][7][i] = ""; }
for (var i = minChan[9];  i < (maxChan[9]+1); i++) { EPG[0][4][i] = "";EPG[1][4][i] = "";EPG[0][5][i] = "";EPG[1][5][i] = "";EPG[0][7][i] = "";EPG[1][7][i] = ""; }

window.onkeydown = onKeyDown;

function onLoad() {
	createPlayer();
	createRecorder();
	embedTeletextPlugin();
	toi.audioOutputService.setVolume(AudioOut, StartVolume);
	toi.audioOutputService.setMuteState(AudioOut, false);
	showDisplay((currChan.toString()), false, 100, 0 );
	play(channels[currChan]);
	eitCache = toi.dvbEitService.createInstance();
	eitCache.setFilterMode(eitCache.FILTER_MODE_PF_AND_SCHEDULE);
//	eitCache.setFilterMode(eitCache.FILTER_MODE_PF_ONLY);
	eitCache.addEventListener(eitCache.ON_CACHE_UPDATED, onCacheUpdated);
	mediaPlayer.addEventListener(mediaPlayer.ON_DATA_AVAILABLE,onDataAvailableEvent);
	showOSD();
	colorkeys.style.fontSize = fsKeys;
	colorkeys.innerHTML = "<font color=red>" +  NN[4] + "</font><font color=green >" + NN[1] + "</font><font color=yellow> Schedule </font><font color=blue> INFO </font>";
	osdvolume.style.fontSize = fsCA;
	osdvolume.style.color = "green";
	osdtime.style.fontSize = fsTime;
	osdtime.style.color = "white";
	osdname.style.fontSize = fsName;
	osdname.style.color = "black";
	osdepg.style.fontSize = fsEpg;
	osdepg.style.color = "white";
	osdca.style.fontSize = fsCA;
	osdca.style.color = "black";
	switchtimer.style.color = "black";
	switchtimer.style.fontSize = fsEpg;
	osdepginfo.style.fontSize = fsEpginfo;
	osdepginfonext.style.fontSize = fsEpginfo;
	videoplane.subtitles = Boolean(ShowSubs);
	mediaList.innerHTML = "<h1><center style='font-size:" + fsRec + ";color:white;'> Please WAIT </center></h1>";
}


function onUnload() {
	try {
		mediaPlayer.close();
		mediaPlayer.releaseInstance();
	if(TimeShift){
		mediaPlayer.stopTimeshiftBuffering();
		mediaPlayer.discardTimeshiftBuffer();
		}
		mediaRecorder.close();
		mediaRecorder.releaseInstance();
	eitCache.removeEventListener(eitCache.ON_CACHE_UPDATED, onCacheUpdated);
	mediaPlayer.removeEventListener(mediaPlayer.ON_DATA_AVAILABLE,onDataAvailableEvent);

	} catch(e) {
		alert(e);
	}
}

function incChan(step) {
    currChan = currChan + step;
    if (currChan > maxChan[ChanGroup]) {
        currChan = minChan[ChanGroup];
    }
    osdnr.style.opacity = isFullscreen; 
    OSDchannr(currChan);
}

function decChan(step) {
    currChan = currChan - step;
    if (currChan < minChan[ChanGroup] ) {
        currChan = maxChan[ChanGroup] ;
    }
    osdnr.style.opacity = isFullscreen; 
    OSDchannr(currChan);
}

function createPlayer() {
  try {
    mediaPlayer = toi.mediaService.createPlayerInstance();
  } catch(e) {
    alert("Failed creating player: " + e);
  }
}

function createRecorder() {
	alert("createRecorder()");
	try {
		mediaRecorder = toi.mediaService.createRecorderInstance();
	} catch(e) {
		alert("Cannot create media recorder: " + e);
	}
}

function play(uri) {
  try {
	if (initialDelayID != -1) {
	  clearTimeout(initialDelayID);
	  initialDelayID = -1;
	}
    if (mediaPlayer.getState() != mediaPlayer.STATE_IDLE) {
      mediaPlayer.close();
    }

	if (ServerAdres[ChanGroup] == "MultiCast" ) {
 	SI=channels[currChan].split("-");
	uri = "239.255." + SI[4] + ":11111";
	} else {
	uri = ServerAdres[ChanGroup] + uri;
	}
	mediaPlayer.open(uri);
	mediaPlayer.play(1000);
	SetLed(1,1,0);

	if(TimeShift){
	    initialDelayID = setTimeout("startTimeshiftBuffering();", 5000);
	}

	if(isFullscreen) {
	showOSD();
	}

	showDisplay((currChan.toString()), false, 100, 0 );
        GetEPG(currChan);
  } catch (e) {
    alert("Failed opening stream: " + e);
    alert("error: " + mediaPlayer.getTimeshiftError().source);
    alert("error: " + mediaPlayer.getTimeshiftError().details);
    return;
  }
}

function preview(urip) {
	if(SwitchGuide) {
	play(urip);
	}
	showChannelList();
	if (isSchedule) {
	//GetSchedule(currChan,10);
	}
}


function onDataAvailableEvent(event) {
	dataAvailable = event.status;
	
	if(event.status==true) {
		updateStreamInfo();
	} 
}


function updateStreamInfo() {

alert("What can this stream do : " + mediaPlayer.getCapabilities());
	var mpCap = "";
if (mediaPlayer.getCapabilities() & 1) {
  // bit is set
	mpCap = " CAPABILITY_PAUSE ";
}
if (mediaPlayer.getCapabilities() & 2) {
  // bit is set
	mpCap = mpCap + "CAPABILITY_REWIND ";
}
if (mediaPlayer.getCapabilities() & 4) {
  // bit is set
	mpCap = mpCap + "CAPABILITY_FASTFORWARD ";
}
if (mediaPlayer.getCapabilities() & 8) {
  // bit is set
	mpCap = mpCap + "CAPABILITY_GETPOSITION ";
}
if (mediaPlayer.getCapabilities() & 16) {
  // bit is set
	mpCap = mpCap + "CAPABILITY_SETPOSITION ";
}
if (mediaPlayer.getCapabilities() & 32) {
  // bit is set
	mpCap = mpCap + "CAPABILITY_FREEZE ";
}
if (mediaPlayer.getCapabilities() & 64) {
  // bit is set
	mpCap = mpCap + "CAPABILITY_TIMESHIFT ";
}
	alert (mpCap);

var streamInfo = mediaPlayer.getStreamInfo();
var cList = streamInfo.availableComponents;
var x;
xx = 0;
AudioInfo[currChan] = "";
for(x=0; x<cList.length;x++) {
//alert ("Read StreamINFO " + cList[x].type);
	if(cList[x].type == 0) {
	xx = xx + 1;
	AudioInfo[currChan] = AudioInfo[currChan] + " Audio " + xx + " " + mediaPlayer.getAudioStreamInfo(cList[x]).encoding + " - " + mediaPlayer.getAudioStreamInfo(cList[x]).language + " , ";
//	alert("language : " + mediaPlayer.getAudioStreamInfo(cList[x]).language);
//	alert("audienceType : " + mediaPlayer.getAudioStreamInfo(cList[x]).audienceType);
//	alert("channelFormat : " + mediaPlayer.getAudioStreamInfo(cList[x]).channelFormat);
//	alert("channelMode : " + mediaPlayer.getAudioStreamInfo(cList[x]).channelMode);
//	alert("encoding : " + mediaPlayer.getAudioStreamInfo(cList[x]).encoding);
//	alert("sublanguage : " + mediaPlayer.getAudioStreamInfo(cList[x]).sublanguage);
//	alert("sampleRate : " + mediaPlayer.getAudioStreamInfo(cList[x]).sampleRate);
	}
	if(cList[x].type == 1) {
	AudioInfo[currChan] = AudioInfo[currChan] + " Video " + mediaPlayer.getVideoStreamInfo(cList[x]).encoding + " size : " + mediaPlayer.getVideoStreamInfo(cList[x]).resolutionX + " x " + mediaPlayer.getVideoStreamInfo(cList[x]).resolutionY;
	if (mediaPlayer.getVideoStreamInfo(cList[x]).aspectRatio == "1") {
	AudioInfo[currChan] = AudioInfo[currChan] + " (4:3)";
	}
	if (mediaPlayer.getVideoStreamInfo(cList[x]).aspectRatio == "2") {
	AudioInfo[currChan] = AudioInfo[currChan] + " (16:9)";
	}

	alert("aspectRatio : " + mediaPlayer.getVideoStreamInfo(cList[x]).aspectRatio);
//	alert("activeFormatDescriptor : " + mediaPlayer.getVideoStreamInfo(cList[x]).activeFormatDescriptor);
//	alert("frameRate : " + mediaPlayer.getVideoStreamInfo(cList[x]).frameRate);
//	alert("componentTag : " + mediaPlayer.getVideoStreamInfo(cList[x]).componentTag);
	alert("encoding : " + mediaPlayer.getVideoStreamInfo(cList[x]).encoding);
	alert("resolutionX : " + mediaPlayer.getVideoStreamInfo(cList[x]).resolutionX);
	alert("resolutionY : " + mediaPlayer.getVideoStreamInfo(cList[x]).resolutionY);
	}


	}


}



function startTimeshiftBuffering() {
    // check that media player is working
    if (mediaPlayer.getState() != mediaPlayer.STATE_PLAYING ) {
      alert("Media Player must be playing when starting timeshift buffering!");
      return;
    }

    mediaPlayer.startTimeshiftBuffering(600);
}


function FullScreen() {
			videoplane.style.width = "100%";
			videoplane.style.height = "100%";
			videoplane.style.left = "0px";
			videoplane.style.top = "0px";
}


function onKeyDown(event) {
    if(isVisible) {
 	onKeyTeletext(event.keyIdentifier);
    } else if(isMediaMenu) {
	onKeyMedia(event.keyIdentifier);
    } else if(isSetupMenu) {
	onKeyMenu(event.keyIdentifier);
    } else {

    switch(event.keyIdentifier) {
    case "Up":
	if(isFullscreen) {
		count = 0;
		prevChan = currChan;
		do
		{
		        incChan(1);
		}
		while (!channels[currChan]);
	        play(channels[currChan]);
	} else {
	// swap up <> down in guide mode
		count = 0;
		do
		{
		        decChan(1);
		}
		while (!channels[currChan]);
	        preview(channels[currChan]);
	}
        break;
    case "Down":
	if(isFullscreen) {
		count = 0;
		prevChan = currChan;
		do
		{
		        decChan(1);
		}
		while (!channels[currChan]);
	        play(channels[currChan]);
	} else {
	// swap up <> down in guide mode
		count = 0;
		do
		{
		        incChan(1);
		}
		while (!channels[currChan]);
	        preview(channels[currChan]);
	}
	break;
    case "Left":
	count = 0;
	if(isFullscreen) {
	defChan[ChanGroup] = currChan;
	do
		{
		ChanGroup = ChanGroup - 1;
		if (protChn[ChanGroup] == 1 && ShowProtectedChannels == 1) {
			ChanGroup = ChanGroup - 1;
			}
		if (ChanGroup < 0) {
			ChanGroup = 9;
			}
		}
	while (!minChan[ChanGroup]);
	currChan = defChan[ChanGroup];
	play(channels[currChan]);
	} else {
	prevChan = currChan;
	if (currChan > (minChan[ChanGroup] + 8)) {
	decChan(9);
	} else {
	currChan = maxChan[ChanGroup] - currChan;
	}
	do
	{
	        decChan(1);
	}
	while (!channels[currChan]);
        preview(channels[currChan]);
	}
	break;
    case "Right":
	count = 0;
	if(isFullscreen) {
	defChan[ChanGroup] = currChan;
	do
		{
		ChanGroup = ChanGroup + 1;
		if (protChn[ChanGroup] == 1 && ShowProtectedChannels == 1) {
			ChanGroup = ChanGroup + 1;
			}
		if (ChanGroup > 9) {
			ChanGroup = 0;
			}
		}
	while (!minChan[ChanGroup]);
	currChan = defChan[ChanGroup];
	play(channels[currChan]);

	} else {
	prevChan = currChan;
	if (currChan < (maxChan[ChanGroup] - 9 )) {
	incChan(9);
	} else {
	currChan = maxChan[ChanGroup] - currChan;
	}
	do
	{
	        incChan(1);
	}
	while (!channels[currChan]);
        preview(channels[currChan]);
	}
	break;
  case "Red":
	if(isFullscreen) {
		if(showClock == 0 )	{
		 	showDisplay("", true, 80, 1 );
			showClock = 1;
		} else if(showClock == 1 ) {
			showClock = 0;
	 		showDisplay((currChan.toString()), false, 100, 0 );
		}
	} else if(isSchedule == 0){
		if(NowNext) {	
			settimer();
			switchtimer.style.opacity = 1;
			setTimeout("switchtimer.style.opacity = 0; ", 2000);
//		} else {
//			switchtimer.innerHTML = "<font color=black size=4><center> Program is running use OK to switch </center></font>";
//			switchtimer.style.opacity = 1;
//			setTimeout("switchtimer.style.opacity = 0; ", 2000);
		}
	}
        break;
   case "Green":
	if(isFullscreen) {
		if(!epgactive) {
			audio = audio + 1;
			is = toi.informationService;
			if(audio == 1) {	
				is.setObject("cfg.media.audio.languagepriority","dut,eng",is.STORAGE_VOLATILE);
				osdlang.style.opacity = 1;
				osdlang.style.fontSize = fsAudio;
				osdlang.style.color = "white";
				osdlang.innerHTML = "<img src='unmute.png'> Nederlands ";
				setTimeout("osdlang.style.opacity = 0; ", 3000);
			} else if(audio == 2) {
				is.setObject("cfg.media.audio.languagepriority","ger,deu,eng",is.STORAGE_VOLATILE);
				osdlang.style.opacity = 1;
				osdlang.style.fontSize = fsAudio;
				osdlang.style.color = "white";
				osdlang.innerHTML = "<img src='unmute.png'> Deutsch ";
				setTimeout("osdlang.style.opacity = 0; ", 3000);
			} else if(audio == 3) {
				is.setObject("cfg.media.audio.languagepriority","eng",is.STORAGE_VOLATILE);
				osdlang.style.opacity = 1;
				osdlang.style.fontSize = fsAudio;
				osdlang.style.color = "white";
				osdlang.innerHTML = "<img src='unmute.png'> English ";
				setTimeout("osdlang.style.opacity = 0; ", 3000);
				audio = 0;
			}
		} else {
		osdepginfo.style.opacity = 1 - osdepginfo.style.opacity ;
		osdepginfonext.style.opacity = 1 - osdepginfo.style.opacity;
		}
	} else if(isSchedule == 0){
		colorkeys.innerHTML = "<font color=red>" +  NN[3 + NowNext] + "</font><font color=green>" + NN[NowNext] + "</font><font color=yellow> Schedule </font><font color=blue> INFO </font>";
		NowNext = 1 - NowNext;
		showChannelList();
	}

	break;
   case "Yellow":
	if(isFullscreen) {
		if(!epgactive) {
				if(!isSchedule) {
				schedule.style.opacity = 1;
				schedule.style.width = "50%";
				schedule.style.height = "75%";
				schedule.style.left = "25%";
				GetSchedule(currChan,15);
				isSchedule = 1;
				} else {
				isSchedule = 0;
				schedule.style.opacity = 0;
				schedule.style.height = "48%";
				schedule.style.width = "100%";
				schedule.style.left = "5%";
				}
		}
	} else {
		GetSchedule(currChan,10);
		schedule.style.opacity = 1 - schedule.style.opacity;
		channelList.style.opacity = 1 - schedule.style.opacity;
		isSchedule = schedule.style.opacity;
		if(isSchedule == 1){
		colorkeys.innerHTML = "<font color=red>" +  NN[4] + "</font><font color=green>" + NN[4] + "</font><font color=yellow> BACK </font><font color=blue>" + NN[4] + "</font>";
		} else {
		colorkeys.innerHTML = "<font color=red>" +  NN[3 + (1 - NowNext)] + "</font><font color=green>" + NN[1 - NowNext] + "</font><font color=yellow> Schedule </font><font color=blue> INFO </font>";
		}
	}
	break;
   case "Blue":
	if(isFullscreen) {
	RestartPortal();
	} else if(isSchedule ==0) {
		SetOsdInfo();
		osdepginfo.style.opacity = 1 - NowNext;
		osdepginfonext.style.opacity = NowNext;
		setTimeout("epgactive = 0; osdepginfo.style.opacity = 0; osdepginfonext.style.opacity = 0;", 5000);
	}
	break;
   case "BrowserBack":
	if(count) {
		count = 0;
		osdnr.style.opacity = 0;
		if(isFullscreen) {
			showDisplay((currChan.toString()), false, 100, 0 );
		}
		Change = 0;
	} else {
		if(isSchedule) {
			isSchedule = 0;
			schedule.style.opacity = 0;
			schedule.style.height = "48%";
			epgactive = 1; // else we get EPGinfo on the screen, bit nasty but works
		}

		if(isFullscreen) {
		//SHOW epg info
			if(!epgactive) {
			SetOsdInfo();
			osdepginfo.style.opacity = 1;
			osdepginfonext.style.opacity = 0;
			epgactive = 1;		
			} else {
			osdepginfo.style.opacity = 0;
			osdepginfonext.style.opacity = 0;
			epgactive = 0;
			}
//		setTimeout("epgactive = 0; osdepginfo.style.opacity = 0; osdepginfonext.style.opacity = 0;", 5000);
		} else if(!isFullscreen){
			isFullscreen = 1;
			FullScreen();
			currChan = preChan;
		}
	}
	break;

   case "Enter":
	// OK key on frontpanel
   case "Accept":
	if(isFullscreen) {
	// fullscreen    
		if(!count) {
			if (osdtimeout) {
				clearTimeout(osdtimeout);
				osdtimeout = 0;
				opacity = 0;
				OSD(opacity);
				break;
				}
	        GetEPG(currChan);
		updateOSDtime(currChan);
		osdepg.innerHTML = "<p>" + EPG[0][7][currChan] + "</p>\n<p>" + EPG[1][7][currChan] + "</p>";
		showOSD();
		} else {
			CheckChannel(Change);
			count = 0;
			if(ChangeOK) { 	
				play(channels[currChan]);
				ChangeOK = 0;
				}
		  }
	} else {
	// if not fullscreen
		if(count){
			CheckChannel(Change);
			count = 0;
			if(ChangeOK) { 	
				preview(channels[currChan]);
				ChangeOK = 0;
				}
		  } else {
		isFullscreen = 1;
		FullScreen();
	        play(channels[currChan]);
		}
	}
        break;

   case "Menu":
		if(isFullscreen) {
		isSetupMenu = 1;
		mainmenu.style.opacity = 0.8;
		menu = 0;
		InitMenu(menu);
		}
		break;
   case "Scroll":
		if(isFullscreen) {
			NowNext = 0;
			videoplane.style.width = (320*Xfactor)+"px";
			videoplane.style.height = (240*Yfactor)+"px";
			videoplane.style.left = (380*Xfactor)+"px";
			videoplane.style.top = (300*Yfactor)+"px";
			isFullscreen = 0;
			isSchedule = 0;
			schedule.style.opacity = 0;
			schedule.style.height = "48%";
			channelList.style.opacity = 1;
			colorkeys.innerHTML = "<font color=red>" +  NN[3 + (1 - NowNext)] + "</font><font color=green>" + NN[1 - NowNext] + "</font><font color=yellow> Schedule </font><font color=blue> INFO </font>";
			colorkeys.style.opacity = 1;
			showChannelList();
			if(!SwitchGuide) {
			preChan = currChan;
			}
		} else {
			isSchedule = 0;
			schedule.style.opacity = 0;
			isFullscreen = 1;
			FullScreen();
			if(!SwitchGuide) {
			currChan = preChan;
			}
		}
		break;
    case "TV":
    case "RADIO":
	if(ChanGroup !== 9) {
	//Radio
	ChanGroup = 9;
	currChan = defChan[9];
	} else {
	//TV
	ChanGroup = 0;
	currChan = defChan[0];
	}
	isSetupMenu = 0;
	mainmenu.style.opacity = 0;
	play(channels[currChan]);
	break;

    case KEY_0:
	digit = 0;
	Makedigit();
        break;
    case KEY_1:
	digit = 1;
	Makedigit();
        break;
    case KEY_2:
	digit = 2;
	Makedigit();
        break;
    case KEY_3:
	digit = 3;
	Makedigit();
        break;
    case KEY_4:
	digit = 4;
	Makedigit();
        break;
    case KEY_5:
	digit = 5;
	Makedigit();
        break;
    case KEY_6:
	digit = 6;
	Makedigit();
        break;
    case KEY_7:
	digit = 7;
	Makedigit();
        break;
    case KEY_8:
	digit = 8;
	Makedigit();
        break;
    case KEY_9:
	digit = 9;
	Makedigit();
        break;
    case "Teletext":
	if(isFullscreen) {
		isVisible = 1;
		setVisible(isVisible);
		}
	break;
    case "VolumeMute":
	state = toi.audioOutputService.getMuteState(AudioOut);
	toi.audioOutputService.setMuteState(AudioOut, !state);
	mute = 1 - state;
        osdmute.style.opacity = mute; 
	break;
    case "VolumeUp":
	Volume = Volume + 10;
        if (Volume > 100) {
            Volume = 100;
        }
        toi.audioOutputService.setVolume(AudioOut, Volume);
	showVolume();
	break;
    case "VolumeDown":
	Volume = Volume - 10;
        if (Volume < 0) {
            Volume = 0;
        }
        toi.audioOutputService.setVolume(AudioOut, Volume);
	showVolume();
	break;

	case "MediaRewind":
	      mediaPlayer.play(mediaPlayer.PACE_REWIND);
		break;
	case "MediaForward":
	      mediaPlayer.play(mediaPlayer.PACE_FASTFORWARD);
		break;
	case "MediaPlayPause":
		if(TimeShift){
			if(mediaPlayer.getState() == mediaPlayer.STATE_PAUSED || mediaPlayer.getState() == mediaPlayer.STATE_FASTFORWARDING || mediaPlayer.getState() == mediaPlayer.STATE_REWINDING) {
				SetLed(1,1,0);
				mediaPlayer.play(mediaPlayer.PACE_PLAY);
				break;
			}
		   	if(mediaPlayer.getState() == mediaPlayer.STATE_PLAYING) {
				SetLed(1,1,10);
				mediaPlayer.play(0);
				break;
			}
		}
		break;
	case "MediaStop":
		try {
		SetLed(1,1,0);
		mediaPlayer.playFromPosition(mediaPlayer.POSITION_LIVE,mediaPlayer.PACE_PLAY);
		} catch(e) {
			alert(e);
		}
	break;
	case KEY_REC:
	case "MediaRecord":
	if (isRecording == 1) {
	recordStop();
	} else {
	recordStart();
	}
	break;

	default:
        break;
    }
  }
}

function Makedigit() {
	prevChan = currChan;
	Change = (Change*10) + digit;
	count = count + 1;
	osdnr.style.opacity = isFullscreen; 
        OSDchannr(Change);
	if(isFullscreen) {
		showDisplay((Change.toString()), false, 100, 0 ); 
	}

    if (count>channeldigits) {
	CheckChannel(Change);
	count = 0;
	}
    if(ChangeOK) { 
	if(isFullscreen) {
	        play(channels[currChan]);
	} else {
	        preview(channels[currChan]);
	}
	ChangeOK = 0;
	}
}

function CheckChannel(CheckThis) {
// function to check if channel exists
	CheckThis = baseChn[ChanGroup] + CheckThis;
	if(channels[CheckThis]) {
		ChangeOK = 1;
		currChan = CheckThis;
	} else {
		ChangeOK = 0;
	}
	if(prevChan == currChan) { 
	ChangeOK = 0 ;
	}
	osdnr.style.opacity = 0;
	if(isFullscreen) {
	showDisplay((currChan.toString()), false, 100, 0 );
	}
	Change = 0;

}


function showDisplay(showtxt,colonState,intensity,currentMode) {
	if(!showClock){
	toi.frontPanelService.setSegmentDisplayState(toi.statics.ToiFrontPanelServiceSegmentDisplayState.create(showtxt,colonState,intensity,currentMode));
	}
}

function SetLed(NumLed,color,blinkfreq){
	var fps = toi.frontPanelService;
	var state = toi.statics.ToiFrontPanelServiceLedState.create(color, blinkfreq);
	fps.setLedState(NumLed, state);
}


function showOSD() {
	if (osdtimeout) {
		clearTimeout(osdtimeout);
	}
	SetOsdInfo();
	opacity = 1;
	OSD(opacity);
	osdtimeout = setTimeout("fadeOut(); osdtimeout = 0;", 3000);
}

function showVolume() {
	if (osdVolumetimeout) {
		clearTimeout(osdVolumetimeout);
	}
	osdvolume.innerHTML = "VOLUME : \uE007" + (new Array(Volume)).join("\uE008") + (new Array(100 - Volume)).join("\uE009") + "\uE00A";
	osdvolume.style.opacity = 1;
	osdVolumetimeout = setTimeout("osdvolume.style.opacity = 0;", 3000);
}


function OSD(opacity) {
    osdmain.style.opacity = opacity;
    osdnr.style.opacity = opacity;
    osdtime.style.opacity = opacity;
    osdname.style.opacity = opacity;
    osdepg.style.opacity = opacity;
    osdca.style.opacity = opacity;
    osdtimer.style.opacity = opacity;
}


function SetOsdInfo() {
    OSDchannr(currChan);
    date_time();
    OSDhtml();
    return;
}

function onCacheUpdated() {
        GetEPG(currChan);
	if (osdtimeout) {
		SetOsdInfo();
	} 
	if (isSchedule) {
		if (!isFullscreen) {
			GetSchedule(currChan,10);
		} else {
			GetSchedule(currChan,15);
		}
	}

}

function OSDchannr(channr) {
    osdnr.innerHTML = "<center>" + Right(channr,3) + "</center>";
    osdnr.style.fontSize = fsChan;
    osdnr.style.color = "black";
}

function OSDhtml(){
    osdtime.innerHTML = result;
    osdname.innerHTML = Left(channelsnames[currChan],30);
    osdepg.innerHTML = "<p>" + EPG[0][7][currChan] + "</p>\n<p>" + EPG[1][7][currChan] + "</p>";
    osdepginfo.innerHTML =  "<center><p style='color:white;' >" + currChan + "\uE003" + channelsnames[currChan] + "</p>" + AudioInfo[currChan] + "<p style='color:white;'>" + EPG[0][7][currChan] + "</p>\n<p style='color:yellow;'>" + EPG[0][4][currChan] + "</p>\n<p>" + Left(EPG[0][5][currChan],750) + "</p></center>";
    osdepginfonext.innerHTML =  "<center><p style='color:white;'>"  + currChan + "\uE003" + channelsnames[currChan] + "</p><p style='color:white;'>" +  EPG[1][7][currChan] + "</p>\n<p style='color:yellow;'>" + EPG[1][4][currChan] + "</p>\n<p>" + Left(EPG[1][5][currChan],750) + "</p></center>";
}

function updateOSDtime(timchan) {

	tijd = EPG[0][2][timchan];
	date = new Date(tijd*1000); 
	tijd = date.toUTCString();
	tijd = new Date(tijd);
	dateCurrent = new Date();
	var EPGminutes = Math.floor((dateCurrent.getTime() - date.getTime()) /1000/60);
	var tm = tijd.getMinutes();
	var th = tijd.getHours();
	if(th<10)
        {
                th = "0"+th;
        }
        if(tm<10)
        {
                tm = "0"+tm;
        }

	EPG[0][7][timchan] =  th + ":" + tm + " (" + EPGminutes + " / " + ((EPG[0][3][timchan])-EPGminutes).toFixed(0) + ")" + " " + EPG[0][1][timchan] + " ";
	if (!EPG[0][2][timchan]) 
	{
		EPG[0][7][timchan] = " ";
	}

}


function settimer() {
	if(SwitchTimer) {	
		tijd = EPG[NowNext][2][currChan];
		date = new Date(tijd*1000); 
		tijd = date.toUTCString();
		tijd = new Date(tijd);
		var tm = tijd.getMinutes();
		var th = tijd.getHours();
		if(th<10) {
                th = "0"+th;
	        }
        	if(tm<10) {
                tm = "0"+tm;
	        }
		dateCurrent = new Date();
		var StartTime = Math.floor((date.getTime() - dateCurrent.getTime()));
		timerChan = currChan;
		TimerActions = "isVisible = 0; isFullscreen = 1; FullScreen(); setVisible(isVisible); currChan = timerChan; play(timerChan); osdtimer.innerHTML = '';SetLed(0,0,0);switchicon = '\uE003';osdca.innerHTML = CAicon + switchicon;"
		// only 1 switch timer possible
		if(switchtimerID) {
			clearTimeout(switchtimerID);
		}
		switchtimerID = setTimeout(TimerActions, StartTime);
		switchtimer.innerHTML = "<p>  Name      : " + EPG[NowNext][1][currChan] + "</p><p>  channel   : " + channelsnames[currChan] +  "</p><p>  Starttime : " + th + ":" + tm + "</p>";
		osdtimer.innerHTML = "<p style='color:black;font-size:" + fsList + ";'>" + th + ":" + tm + "</p>";
		SetLed(0,2,1);
		switchicon = "\uE00C";
		osdca.innerHTML = CAicon + switchicon;
	} else {
	//
	// No Switch timer so send timer info to Server
	//
	}
}

// linker n tekens van string
function Left(str, n){
  if (n <= 0)
    return "";
  else if (n > String(str).length)
    return str;
  else
    return String(str).substring(0,n);
}

// rechter n tekens van string
function Right(str, n){
  if (n <= 0)
    return "";
  else if (n > String(str).length)
    return str;
  else {
    var iLen = String(str).length;
    return String(str).substring(iLen, iLen - n);
  }
}

function fadeIn() {
    opacity += 0.2;
	    OSD(opcity);
    if (opacity >= 1) {
	setTimeout("fadeOut()", 200);
	return;
    }
    setTimeout("fadeIn()", 100);
}

function fadeOut() {
    opacity -= 0.5;
	OSD(opacity);
    if (opacity <= 0) {
	return;
    }
    setTimeout("fadeOut()", 100);
}

function RestartPortal(){

    try {
	ids = toi.applicationService.getApplicationIds();
	for ( i = 0; i < ids.length; ++i ){
	    info = toi.applicationService.getInfo(ids[i]);
	    if (info.applicationName == "WebKit Portal"){
		 dump("Killing app " + ids[i] + ": " + info.applicationName);
		 toi.applicationService.kill(ids[i]);
	    }
	}
    }
    catch(e) { dump(e) };
}

function date_time()
{
        date = new Date;
        year = date.getFullYear();
        month = date.getMonth();
        d = date.getDate();
        day = date.getDay();
        h = date.getHours();
        if(h<10)
        {
                h = "0"+h;
        }
        m = date.getMinutes();
        if(m<10)
        {
                m = "0"+m;
        }
        s = date.getSeconds();
        if(s<10)
        {
                s = "0"+s;
        }
        result = ''+days[day]+' '+d+' '+months[month]+' '+year+' '+h+':'+m;
        return;
}

// EPG Section

function GetEPG(epgchan)
{
	EPG[0][7][epgchan] = "";
	EPGShortnow = "";
	EPGExtnow = "";
	EPG[1][7][epgchan] = "";
	EPGShortnext = "";
	EPGExtnext = "";
	SI="";
  try {

	 StreamInfo(epgchan);

	 eitService = toi.statics.ToiDvbEitCacheServiceItem.create(SI[1],SI[2],SI[3]);
	 eitCache.addService(eitService);
	 event = eitCache.getPresentEvent(eitService);
	if(event.freeCaMode){
		CAicon = "\uE00D";
	} else {
		CAicon = "\uE00F";
	}

		osdca.innerHTML = CAicon + switchicon;
	if (event.name)	{
	 events = eitCache.getEvents(eitService, 1000000000, 2000000000);
 	    extEventsnow = eitCache.getExtendedEventInfo(eitService, events.infoSequence[0].eventId);
	    EPGShortnow = extEventsnow.shortInfo;
	    EPGExtnow = extEventsnow.extendedInfo;
	    Extok = 1;
	} else { Extok = 0; }

	EPG[0][1][epgchan] = event.name;
	EPG[0][2][epgchan] = event.time;
	EPG[0][3][epgchan] = (event.duration/60);
	EPG[0][4][epgchan] = "";
	EPG[0][5][epgchan] = "";

	if(EPGShortnow) {
	EPG[0][4][epgchan] = EPGShortnow;
	} else {
	EPG[0][4][epgchan] = "";
	}
	if(EPGExtnow) {
	EPG[0][5][epgchan] = EPGExtnow;
	} else {
	EPG[0][5][epgchan] = "";
	}
	updateOSDtime(epgchan);

	 event = eitCache.getFollowingEvent(eitService);
	if (Extok) {
		for (var i = 0; i < events.infoSequence.length && i < 4; i++) {
	 	    extEvents = eitCache.getExtendedEventInfo(eitService, events.infoSequence[i].eventId);
			if (extEvents.eventId == event.eventId) {
			    EPGShortnext = extEvents.shortInfo;
			    EPGExtnext = extEvents.extendedInfo; 
			}
		}
	}

	EPG[1][1][epgchan] = event.name;
	EPG[1][2][epgchan] = event.time;
	EPG[1][3][epgchan] = (event.duration/60);
	EPG[1][4][epgchan] = "";
	EPG[1][5][epgchan] = "";



	if(EPGShortnext) {
	EPG[1][4][epgchan] = EPGShortnext;
	} else {
	EPG[1][4][epgchan] = "";
	}
	if(EPGExtnext) {
	EPG[1][5][epgchan] = EPGExtnext;
	} else {
	EPG[1][5][epgchan] = "";
	}
	tijd = event.time;
	date = new Date(tijd*1000); 
	tijd = date.toUTCString();
	tijd = new Date(tijd);
	var tm = tijd.getMinutes();
	var th = tijd.getHours();
	if(th<10)
        {
                th = "0"+th;
        }
        if(tm<10)
        {
                tm = "0"+tm;
        }
	
	 EPG[1][7][epgchan] = th + ":" + tm + " (" + (event.duration/60).toFixed(0) + ")" + "          " + event.name + " ";

	if (!event.time) 
	{
		EPG[1][7][epgchan] = " ";
	}


  } catch(e) {
    alert("Get EPG problem: " + e);
  }
} 



function GetSchedule(schchan,tablelength){
	SI = "";
  try {
	 StreamInfo(schchan);

	 eitService = toi.statics.ToiDvbEitCacheServiceItem.create(SI[1],SI[2],SI[3]);
	 eitCache.addService(eitService);
	 event = eitCache.getPresentEvent(eitService);
	 events = eitCache.getEvents(eitService, 1000000000, 2000000000);

	if (event.name)	{
	    if (events.more) {
	      var t = eitCache.getEvents(eitService, 1000000000, 2000000000);
	      events.infoSequence.concat(t.infoSequence);
	      events.more = t.more;
	    }

	    var txt = "<table><tr>";
	    var i = 0;
	    for (i = 0; i < events.infoSequence.length && i < tablelength; i++) {

		while ((i > 0) && (events.infoSequence[i].eventId == events.infoSequence[(i-1)].eventId)) {
			i = i + 1;
		}

		tijd = events.infoSequence[i].time;
		date = new Date(tijd*1000); 
		tijd = date.toUTCString();
		tijd = new Date(tijd);
		var tm = tijd.getMinutes();
		var th = tijd.getHours();
		if(th<10)
	        	{
	                th = "0"+th;
	        	}
	        if(tm<10)
	        	{
	                tm = "0"+tm;
	        	}

	      txt = txt + "<td style='font-size:" + fsSchedList + ";'>\uE003\uE003\uE003\uE003\uE003" + th + ":" + tm + "     (" + (events.infoSequence[i].duration/60).toFixed(0) + ")  " + Left(events.infoSequence[i].name,30) + "</td></tr>";
	    }
	   txt = txt + "</table>";
	   schedule.innerHTML = "<p style='color:white;font-size:" + fsSched + ";'>" + "\uE003" + schchan + "\uE003" + channelsnames[schchan] + txt + "</p>";
	} else {
	  schedule.innerHTML = "<p style='color:white;font-size:" + fsSched + ";'>" + "\uE003" + schchan + "\uE003" + channelsnames[schchan] + "</p>";
	}

  } catch(e) {
    alert("Get EPG problem: " + e);
	  schedule.innerHTML = "<p style='color:white;font-size:" + fsSched + ";'>" + "\uE003" + schchan + "\uE003" + channelsnames[schchan] + "</p><p> NO EPG </p>";
  }

}


function StreamInfo(si) {

	// streaminfo
	// SI[x] 0-sat,1-NID,2-TID,3-SID
 	SI=channels[si].split("-");
	is = toi.informationService;

	if(SI[0]=="S19.2E") {
	// Default on 19E German.
	is.setObject("cfg.locale.ui","ger",is.STORAGE_VOLATILE);
	}

	if(SI[0]=="S28.2E") {
	// Default on 28E English
	is.setObject("cfg.locale.ui","eng",is.STORAGE_VOLATILE);
	} 

	if(SI[1]=="8720") {
	// KPN DVB-T
	is.setObject("cfg.locale.ui","dut",is.STORAGE_VOLATILE);
	}

	if(SI[1]=="133") {
	//sky deutchland
	is.setObject("cfg.locale.ui","DEU",is.STORAGE_VOLATILE);
	}

	if(SI[1]=="64511") {
	//sky Italia
	is.setObject("cfg.locale.ui","ita",is.STORAGE_VOLATILE);
	}

	if(SI[1]=="3" || SI[1]=="53") {
	//Canal Digitaal/ TV Vlaanderen (NID:3 is used for more than only CDS/TVV on 23East)
	is.setObject("cfg.locale.ui","dut",is.STORAGE_VOLATILE);
	}

	if(SI[1]=="3" && ( SI[2]=="3210" || ( SI[2]=="3219" && SI[3]!=="13135") )) {
	//Canal Digitaal/ TV Vlaanderen use CZE channels on 23East
	// Strangly set filter to cze but epg is in Dutch. (But not for JimJam)
	is.setObject("cfg.locale.ui","cze",is.STORAGE_VOLATILE);
	}

	if((SI[0]=="S13.0E" && SI[3]=="14003") || (SI[0]=="S13.0E" && SI[3]=="14009") || (SI[0]=="S13.0E" && SI[3]=="14051") || (SI[0]=="S13.0E" && SI[3]=="951")) {
	//Swiss ITA channels
		is.setObject("cfg.locale.ui","ita",is.STORAGE_VOLATILE);
	}

	if((SI[0]=="S13.0E" && SI[2]=="12800")) {
		is.setObject("cfg.locale.ui","eng",is.STORAGE_VOLATILE);
	}


	if((SI[0]=="S13.0E" && SI[3]=="14002") || (SI[0]=="S13.0E" && SI[3]=="14008") || (SI[0]=="S13.0E" && SI[3]=="17203") || (SI[0]=="S13.0E" && SI[3]=="17204") ) {
	//Swiss FRA channels
		is.setObject("cfg.locale.ui","fra",is.STORAGE_VOLATILE);
	}

	if((SI[0]=="S13.0E" && SI[3]=="17201") || (SI[0]=="S13.0E" && SI[3]=="17202") || (SI[0]=="S13.0E" && SI[3]=="901") || (SI[0]=="S13.0E" && SI[3]=="907") || (SI[0]=="S13.0E" && SI[3]=="911") ) {
	//Swiss GER channels
		is.setObject("cfg.locale.ui","ger",is.STORAGE_VOLATILE);
	}

	if((SI[0]=="S13.0E" && SI[2]=="1400") ) {
		is.setObject("cfg.locale.ui","pol",is.STORAGE_VOLATILE);
	}

	if(SI[0]=="S19.2E" && (SI[2]=="1074") || (SI[2]=="1018") || (SI[2]=="1024") || (SI[2]=="1068") || (SI[2]=="1070") || (SI[2]=="1072") || (SI[2]=="1076") || (SI[2]=="1080") || (SI[2]=="1084") || (SI[2]=="1086") || (SI[2]=="1090") || (SI[2]=="1092") || (SI[2]=="1094") || (SI[2]=="1096") || (SI[2]=="1100") || (SI[2]=="1102") || (SI[2]=="1106") || (SI[2]=="1110") || (SI[2]=="1112") || (SI[2]=="1114") || (SI[2]=="1116") || (SI[2]=="1118") || (SI[2]=="1120")) {
	//CanalSat S19.2
		is.setObject("cfg.locale.ui","fra",is.STORAGE_VOLATILE);
	}

}


// End of EPG section



// Channelslist / EPG Guide
//
// show currchan - 5
// highlite currchan
// show currchan + 5
// 
// check if chan is OK
// 
function showChannelList() {
	var liststyle = "";
	var htmlstring = "<table border='0'><tr>";
	listChan = currChan-5;
	for(var i=currChan-5; i<=currChan+5; i++) {
		do
			{
				listChan = listChan + 1;
				if (listChan<minChan[ChanGroup]) {
					listChan=maxChan[ChanGroup];
					}
				if (listChan>maxChan[ChanGroup]) {
					listChan=minChan[ChanGroup];
				}
			}

		while (!channels[listChan] && (listChan<maxChan[ChanGroup]));
		if ( listChan == currChan) { 
			GetEPG(listChan);
			liststyle = "background:#fc5;";
		}  else {
			liststyle = "";
		}
		EpgInfo[0] = EPG[0][7][listChan];
		EpgInfo[1] = EPG[1][7][listChan];
		htmlstring = htmlstring + "<td style='" + liststyle + "font-size:" + fsList + ";'>" + listChan + "\uE003</td><td style='" + liststyle + "font-size:" + fsList + ";'>" + Left(channelsnames[listChan],15) + "\uE003</td><td style='" + liststyle + "font-size:" + fsList + ";'>"  + Left(EpgInfo[NowNext],64) + "</td></tr>";
	}
	htmlstring = htmlstring + "</table>";
	channelList.innerHTML = htmlstring;
        chanlistepg.innerHTML = "<center><p style='color:black;font-size:" + fsEpg + ";'>" + EPG[NowNext][1][currChan] + "</p><p style='color:black;font-size:" + fsList + ";'>" + Left(EPG[NowNext][4][currChan],250) + "</p></center>" ;

}


// END of Channelslist / EPG Guide

// TeleTXT section

function embedTeletextPlugin() {
  teletext = document.createElement("embed");
  teletext.id = "teletext";
  teletext.type = "application/motorola-teletext-plugin";
  teletext.style.position = "absolute";
  teletext.style.width = "100%";
  teletext.style.height = "100%";
  teletext.style.top = "10px"; // has to be 1 rather than 0
  teletext.style.left = "10px"; // has to be 1 rather than 0
  teletext.style.zIndex = "501";
  return teletext;
}


function setVisible(isVisible) {
  if (isVisible) {
    videoplane.style.width = "50%";
    videoplane.style.left = "50%";
    document.body.appendChild(teletext);
    teletext.style.width = "50%";
    teletext.style.visibility = "visible";
    channelList.style.visibility = "hidden";
    colorkeys.style.visibility = "hidden";
  } else {
    teletext.style.visibility = "hidden";
    channelList.style.visibility = "visible";
    colorkeys.style.visibility = "visible";
  }
}


function onKeyTeletext(keyCode) {
  switch(keyCode) {
    case "Left":
      teletext.api.gotoNextPage();
    break;
    case "Right":
      teletext.api.gotoPreviousPage();
    break;
    case "Red":
      teletext.api.inputRedKey();
    break;
    case "Green":
      teletext.api.inputGreenKey();
    break;
    case "Yellow":
      teletext.api.inputYellowKey();
    break;
    case "Blue":
      teletext.api.inputCyanKey();
    break;
    case "MediaRewind":
      teletext.api.gotoPreviousSubpage();
    break;
    case "MediaForward":
      teletext.api.gotoNextSubpage();
    break;
    case "MediaStop":
	teletext.style.width = "100%";
	teletext.api.transparent = !teletext.api.transparent;
	FullScreen();
    break;
    case "BrowserBack":
    case "Teletext":
	isVisible = 0;
	FullScreen();
	setVisible(isVisible);		
    break;

    case "TV":
      teletext.api.gotoIndexPage();
    break;

	case KEY_0:
	    teletext.api.inputDigit(0);
	break;
	case KEY_1:
	    teletext.api.inputDigit(1);
	break;
	case KEY_2:
	    teletext.api.inputDigit(2);
	break;
	case KEY_3:
	    teletext.api.inputDigit(3);
	break;
	case KEY_4:
	    teletext.api.inputDigit(4);
	break;
	case KEY_5:
	    teletext.api.inputDigit(5);
	break;
	case KEY_6:
	    teletext.api.inputDigit(6);
	break;
	case KEY_7:
	    teletext.api.inputDigit(7);
	break;
	case KEY_8:
	    teletext.api.inputDigit(8);
	break;
	case KEY_9:
	    teletext.api.inputDigit(9);
	break;



  }
}

// end of TeleTXT section


// Menu section

function onKeyMenu(keyCode) {
  switch(keyCode) {
    case "BrowserBack":
	if (menu !== 0) {
		menu = 0;	
		InitMenu(menu);
		break;
		}
    case "Menu":
	isSetupMenu = 0;
	mainmenu.style.opacity = 0;
    break;
    case "Left":
    break;
    case "Right":
    break;
    case "Red":
	if (menu == 1) {
		if(showClock == 0 )	{
		 	showDisplay("", true, 80, 1 );
			showClock = 1;
		} else if(showClock == 1 ) {
			showClock = 0;
	 		showDisplay((currChan.toString()), false, 100, 0 );
		}
	}
	InitMenu(menu);
    break;
    case "Green":
		if (menu == 1) {
			audio = audio + 1;
			is = toi.informationService;
			if(audio == 1) {	
				is.setObject("cfg.media.audio.languagepriority","dut,eng",is.STORAGE_VOLATILE);
			} else if(audio == 2) {
				is.setObject("cfg.media.audio.languagepriority","ger,deu,eng",is.STORAGE_VOLATILE);
			} else if(audio == 3) {
				is.setObject("cfg.media.audio.languagepriority","eng",is.STORAGE_VOLATILE);
				audio = 0;
			}
		}
	InitMenu(menu);
    break;
    case "Yellow":
    break;
    case "Blue":
	if (menu == 1) {
		if(SwitchGuide == 0 )	{
			SwitchGuide = 1;
		} else if(SwitchGuide == 1 ) {
			SwitchGuide = 0;
		}
	}
	InitMenu(menu);
    break;
    case "MediaRewind":
    break;
    case "MediaForward":
    break;
    case "MediaStop":
    break;
    case "Teletext":
    break;
    case "TV":
    break;
	case KEY_1:
		if (menu == 0) {
		menu = 1;
		} else if (menu == 1) {
		 ShowSubs = 1 - ShowSubs;
		 videoplane.subtitles = Boolean(ShowSubs); // Enable subtitles or Disable subtitles
		} else if (menu == 2) {
		clearTimeout(switchtimerID);
		switchtimerID = 0;
		osdtimer.innerHTML = "";
		switchicon = "\uE003";
		osdca.innerHTML = CAicon + switchicon;
		SetLed(0,0,0);
		}

	InitMenu(menu);
	break;
	case KEY_2:
		if (menu == 0) {
			isSetupMenu = 0;
			mediaList.style.opacity = 0.8;
			mainmenu.style.opacity = 0;
			setTimeout("getRecList();LoadMediaSettings();",100);
			}
		if (menu == 1) {
			is = toi.informationService;
			if(substype == 0 ) { 	
				is.setObject("cfg.media.subtitling.typepriority","hearing_impaired,normal",is.STORAGE_VOLATILE);
				substype = 1;
			} else {
				is.setObject("cfg.media.subtitling.typepriority","normal,hearing_impaired",is.STORAGE_VOLATILE);
				substype = 0;
			}
		}
		InitMenu(menu);
	break;
	case KEY_3:
		if (menu == 0) {
			menu = 2;
		} else if (menu == 1) {
			is = toi.informationService;
			if(subsmode == 0 ) {	
				is.setObject("cfg.media.subtitling.modepriority","Teletext,DVB",is.STORAGE_VOLATILE);
				subsmode = 1;
			} else {
				is.setObject("cfg.media.subtitling.modepriority","DVB,Teletext",is.STORAGE_VOLATILE);
				subsmode = 0;
			}
		} 
	InitMenu(menu);
	break;
	case KEY_4:
		if (menu == 1) {
			audiotype = audiotype + 1;
			is = toi.informationService;
			if(audiotype == 1) {	
				is.setObject("cfg.media.audio.typepriority","normal,hearing_impaired,visually_impaired",is.STORAGE_VOLATILE);
			} else if(audiotype == 2) {
				is.setObject("cfg.media.audio.typepriority","hearing_impaired,visually_impaired",is.STORAGE_VOLATILE);
			} else if(audiotype == 3) {
				is.setObject("cfg.media.audio.typepriority","visually_impaired",is.STORAGE_VOLATILE);
				audiotype = 0;
			}
		}
	InitMenu(menu);
	break;
	case KEY_5:
		if (menu == 1) {
		ShowProtectedChannels = 1 - ShowProtectedChannels;
		InitMenu(menu);
		}
	break;
	case KEY_6:
	break;
	case KEY_7:
	break;
	case KEY_8:
	break;
	case KEY_9:
		if (menu == 0) {
			isSetupMenu = 0;
			mediaList.style.opacity = 0.8;
			mainmenu.style.opacity = 0;
			getRecList2();
			LoadMediaSettings();
//			setTimeout("getRecList2();LoadMediaSettings();",100);
			}
	break;
	case KEY_0:
		if (menu == 0) {
		RestartPortal();
		} else {
		menu = 0;	
		InitMenu(menu);
		}
	break;

	default:
        break;
  }
}

function InitMenu(menu) {

if(menu == 0) {
// Main Menu
	
	mainmenu.innerHTML = "<h1><center style='font-size:" + fsMenuMain + ";color:white;'> MainMenu \n ( " + Version + " )</center></h1><pre style='color:black;font-size:" + fsMenu + ";'>   1 - SettingsMenu \n   2 - Recordings \n   3 - TimersMenu\n   4 -\n   5 -\n   6 -\n   7 -\n   8 -\n   9 -\n   0 - Restart Portal </pre>";
}

if(menu == 1) {
// settings menu
	mainmenu.innerHTML = "<h1><center style='font-size:" + fsMenuMain + ";color:white;'> Settings </center></h1><pre style='color:black;font-size:" + fsMenu + ";'><font style='color:red;font-size:" + fsMenu + ";'>   Frontdisplay Clock : " + Boolean(showClock) + "</font><font style='color:green;font-size:" + fsMenu + ";'>\n   Prio audio track : " + (toi.informationService.getObject("cfg.media.audio.languagepriority")) + "</font><font style='color:blue;font-size:" + fsMenu + ";'>\n   Preview guide : " + Boolean(SwitchGuide) + "</font>\n   1 - Show Subs : " + Boolean(ShowSubs) + "\n   2 - Subs Type Prio : " + (toi.informationService.getObject("cfg.media.subtitling.typepriority")) + "\n   3 - Subs Mode Prio : " + (toi.informationService.getObject("cfg.media.subtitling.modepriority")) + "\n   4 - Audio Type Prio : " + (toi.informationService.getObject("cfg.media.audio.typepriority")) + "\n   5 - Protection : " + Boolean(ShowProtectedChannels) + "\n\n\n\n   0 - MainMenu </pre>";
}

if(menu == 2) {
// Timers menu
	mainmenu.innerHTML = "<h1><center style='font-size:" + fsMenuMain + ";color:white;'> Timers </center></h1><pre style='color:black;font-size:" + fsMenu + ";'>\n   1 - Switch timer : " + Boolean(switchtimerID) + "" + "\n\n\n\n   0 - MainMenu </pre>";
}


}

// End of Menu section

// Media Player Section

function LoadMediaSettings() {
		isMediaMenu = 1;
		showDisplay("STOP", false, 100, 0 );
		currMed = 0;
		showMediaList();
		mediaPlayer.addEventListener(mediaPlayer.ON_POSITION_CHANGED, ShowMediaOSD);
}

function UnloadMediaSettings() {
	mediaPlayer.removeEventListener(mediaPlayer.ON_POSITION_CHANGED, ShowMediaOSD);
	mediaList.style.opacity = 0;
	mediaList.innerHTML = "<h1><center style='font-size:" + fsRec + ";color:white;'> Please WAIT </center></h1>";
 	showDisplay((currChan.toString()), false, 100, 0 );
	isMediaMenu = 0;
	if (mediaPlayer.getState() != mediaPlayer.STATE_PLAYING ) {
        play(channels[currChan]);
	}
}



function onKeyMedia(keyCode) {
  switch(keyCode) {
    case "BrowserBack":
    case "TV":
	UnloadMediaSettings();
        break;
    break;
    case "Down":
	if (mediaList.style.opacity != 0) {
	do
	{
	        incMed(1);
	}
	while (!recTitl[currMed]);
	showMediaList();
	} else {
	      mediaPlayer.play(0);
	      showDisplay("PAUS", false, 100, 0 );
	}
        break;
    case "Up":
	if (mediaList.style.opacity != 0) {
	do
	{
	        decMed(1);
	}
	while (!recTitl[currMed]);
	showMediaList();
	} else {
	      mediaPlayer.play(mediaPlayer.PACE_PLAY);
	      showDisplay("PLAY", false, 100, 0 );
	}
	break;
  case "Accept":
	if (mediaList.style.opacity != 0) {
	mediaList.style.opacity = 0;
	playRec(recLink[currMed]);
	} else {
	osdmedia.style.opacity = 1 - osdmedia.style.opacity;
	ShowMediaOSD();
//	mediaPlayer.playFromPosition(12000,1000);
	}
        break;
   case "Green":
			audio = audio + 1;
			is = toi.informationService;
			if(audio == 1) {	
				is.setObject("cfg.media.audio.languagepriority","dut,eng",is.STORAGE_VOLATILE);
				osdlang.style.opacity = 1;
				osdlang.style.fontSize = fsAudio;
				osdlang.style.color = "white";
				osdlang.innerHTML = "<img src='unmute.png'> Nederlands ";
				setTimeout("osdlang.style.opacity = 0; ", 3000);
			} else if(audio == 2) {
				is.setObject("cfg.media.audio.languagepriority","ger,deu,eng",is.STORAGE_VOLATILE);
				osdlang.style.opacity = 1;
				osdlang.style.fontSize = fsAudio;
				osdlang.style.color = "white";
				osdlang.innerHTML = "<img src='unmute.png'> Deutsch ";
				setTimeout("osdlang.style.opacity = 0; ", 3000);
			} else if(audio == 3) {
				is.setObject("cfg.media.audio.languagepriority","eng",is.STORAGE_VOLATILE);
				osdlang.style.opacity = 1;
				osdlang.style.fontSize = fsAudio;
				osdlang.style.color = "white";
				osdlang.innerHTML = "<img src='unmute.png'> English ";
				setTimeout("osdlang.style.opacity = 0; ", 3000);
				audio = 0;
			}
	break;
    case "MediaRewind":
	    if (mediaPlayer.getState() != mediaPlayer.STATE_IDLE) {
	      mediaPlayer.play(-4000);
	    showDisplay("REW", false, 100, 0 );
	    }
    break;
    case "MediaForward":
	    if (mediaPlayer.getState() != mediaPlayer.STATE_IDLE) {
	      mediaPlayer.play(4000);
	    showDisplay("FF", false, 100, 0 );
	    }
    break;
    case "MediaStop":
	    if (mediaPlayer.getState() != mediaPlayer.STATE_IDLE) {
	    mediaPlayer.close();
	    }
	    if (isRecording == 1) { 
		recordStop();
		isRecording = 0;
	    }
	    mediaList.style.opacity = 0.8;
	    showDisplay("STOP", false, 100, 0 );
	    showMediaList();
    break;
	case "MediaPlayPause":
	    if (mediaPlayer.getState() != mediaPlayer.STATE_PAUSED) {
	      mediaPlayer.play(0);
	      showDisplay("PAUS", false, 100, 0 );
	    } else {
	      mediaPlayer.play(1000);
	      showDisplay("PLAY", false, 100, 0 );
    	    }
	break;

    case "VolumeMute":
	state = toi.audioOutputService.getMuteState(AudioOut);
	toi.audioOutputService.setMuteState(AudioOut, !state);
	mute = 1 - state;
        osdmute.style.opacity = mute; 
	break;
    case "VolumeUp":
	Volume = Volume + 10;
        if (Volume > 100) {
            Volume = 100;
        }
        toi.audioOutputService.setVolume(AudioOut, Volume);
	showVolume();
	break;
    case "VolumeDown":
	Volume = Volume - 10;
        if (Volume < 0) {
            Volume = 0;
        }
        toi.audioOutputService.setVolume(AudioOut, Volume);
	showVolume();
	break;
	default:
        break;
  }
}

function getRecList() {
xmlhttp=new XMLHttpRequest();
xmlhttp.open("GET",(recServ + "/recordings.xml?" + new Date().getTime()),false);
xmlhttp.send();
xmlDoc=xmlhttp.responseXML; 
var x=xmlDoc.getElementsByTagName("item");
nrMedia = x.length - 1;
for (i=0;i<x.length;i++)
  { 
  recTitl[i] = (x[i].getElementsByTagName("title")[0].childNodes[0].nodeValue);
  recLink[i] = (x[i].getElementsByTagName("link")[0].childNodes[0].nodeValue);
  recDesc[i] = (x[i].getElementsByTagName("description")[0].childNodes[0].nodeValue);
  }

}

function getRecList2() {
recTitl[0] = "RTSP Stream";
recLink[0] = "rtsp://192.168.3.15:5554/MyVideo";
recDesc[0] = " ";
recTitl[1] = "RTP Stream";
recLink[1] = "239.255.42.42:1234 ";
recDesc[1] = " ";
recTitl[2] = "RTSP 00001 Stream";
recLink[2] = "rtsp://192.168.3.15/00001.ts";
recDesc[2] = " ";
nrMedia = 2;

}



function showMediaList() {
	var liststyle = "";
	var htmlstring = "<h1><center style='font-size:" + fsRec + ";color:white;'> RECORDINGS </center></h1><table border='0'><tr>";
	listMed = currMed-7;
	for(var i=currMed-7; i<=currMed+7; i++) {
		if (listMed<0) {
			listMed=nrMedia-2;
			}
		if (listMed>nrMedia-1) {
			listMed= -1;
			}
			do
			{
				listMed = listMed + 1;
			}
			while (!recTitl[listMed] && (listMed<nrMedia));
		if ( listMed == currMed) { 
			liststyle = " style='background:#fc5;-webkit-border-radius:25px;";
		}  else {
			liststyle = " style='";
		}
		htmlstring = htmlstring + "<td" + liststyle + "font-size:" + fsReclist + ";'>\uE003\uE003" + Left(recTitl[listMed],60) + "</td></tr>";
	}
	htmlstring = htmlstring + "</table>";
	mediaList.innerHTML = htmlstring;
}


function incMed(step) {
    currMed = currMed + step;
    if (currMed == nrMedia + 1) {
        currMed = 0;
    }
}

function decMed(step) {
    currMed = currMed - step;
    if (currMed < 0) {
        currMed = nrMedia;
    }
}

function playRec(uri) {
  try {
    if (mediaPlayer.getState() != mediaPlayer.STATE_IDLE) {
      mediaPlayer.close();
    }
	mediaPlayer.open(uri);
	mediaPlayer.play(1000);
	showDisplay("PLAY", false, 100, 0 );
  } catch (e) {
    alert("Failed opening recording: " + e);
    return;
  }
}


function createNewAsset() {
	try {
		assetId = toi.assetManagerService.createAsset(toi.assetManagerService.ASSET_PVR);
		alert("Created " + assetId);
	} catch(e) {
		alert("Couldn't create asset: " + e);
	}
}

function recordStart() {
	createNewAsset();
	uri = ServerAdres + channels[currChan];
	alert("opening mediaRecorder...");
	try {
		mediaRecorder.open(uri, assetId);
	} catch(e) {
		alert("Cannot open mediaRecorder. " + e);
	}

	try {
		mediaRecorder.record();
		isRecording = 1;
	} catch(e) {
		alert("Cannot record! " + e);
	}
}


function recordStop() {
	try {
		mediaRecorder.close();
		isRecording = 0;

	} catch(e) {
		alert("Cannot stop mediaRecorder! " + e);
	}
}

function ShowMediaOSD() {
// Display Name/ length 

	osdmedia.innerHTML = "<p style='color:white;font-size:" + fsMedia +";'> getCapabilities : " + mediaPlayer.getCapabilities() + " Elapsed time : " + mediaPlayer.getPosition() + "</p>";
}


</script>


	<body style="background:#ccc;" onload="onLoad()" onunload="onUnload()">
    <embed type="application/x-motorola-toi" hidden="true">

	<div id="channelList" style="background:#bbb; width:100%; height:48%; position:absolute; left:7%; top:4%;"></div>


	<div id="colorkeys" style="width:100%; position:absolute; left:10%; top:84%;"></div>

	<div id="chanlistepg" style="width:42%; position:absolute; left:7%; top:50%;"> 	</div>
	<div id="switchtimer" style="background:#3366ff;width:42%; position:absolute; left:21%; top:26%;z-index:10;opacity:0;"></div>


	<videoplane id='videoplane' style='position:absolute; left:0px; top:0px; height: 100%; width: 100%; z-index:500;'></videoplane>

	<div id="osdvolume" style="width:63%; position:absolute; left:10%; top:80%;z-index:501;fontFamily:VDRSymbolsSans;opacity:0;">Volume : </div>
	<div id="osdmedia" style="width:63%; position:absolute; left:21%; top:69%;z-index:505;fontFamily:VDRSymbolsSans;opacity:0;"></div>

	<div id="osdmain" style="background:#3366ff;width:76%; position:absolute; left:10%; top:60%; bottom:9%;z-index:505;-webkit-border-radius:50px;"></div>
	<div id="osdtime" style="width:42%; position:absolute; left:58%; top:63%;z-index:505;"></div>
	<div id="osdname" style="width:69%;height:4%; position:absolute; left:12%; top:65%;z-index:505;"></div>
	<div id="osdepg" style="width:63%; position:absolute; left:21%; top:69%;z-index:505;"></div>
	<div id="osdtimer" style="width:7%; position:absolute; left:12%; top:69%;z-index:505;"></div>
	<div id="osdca" style="width:3%; position:absolute; left:80%; top:67%;z-index:505;fontFamily:VDRSymbolsSans;"></div>

	<div id="osdnr" style="background:red;width:10%;height:9%; position:absolute; left:12%; top:56%;z-index:505;opacity:0;-webkit-border-radius:25px;"></div>

	<div id="osdepginfo" style="background:#3366ff;width:80%; position:absolute; left:10%; top:10%;z-index:510;opacity:0;-webkit-border-radius:50px;"></div>
	<div id="osdepginfonext" style="background:#3366ff;width:80%; position:absolute; left:10%; top:10%;z-index:510;opacity:0;-webkit-border-radius:50px;"></div>
	<div id="schedule" style="background:#3366ff; width:50%; height:48%; position:absolute; left:25%; top:10%;opacity:0;z-index:510;-webkit-border-radius:50px;"></div>

	<div id="osdmute" style="width:7%; position:absolute; left:76%; top:9%;z-index:515;opacity:0;"><img src="mute.png"></div>
	<div id="osdlang" style="width:7%; position:absolute; left:76%; top:9%;z-index:515;opacity:0;"></div>

	<div id="mainmenu"  style="background:#3366ff;width:76%; position:absolute; left:10%; top:10%; bottom:10%;z-index:520;opacity:0;-webkit-border-radius:50px;"></div>
	<div id="mediaList" style="background:#3366ff;width:76%; position:absolute; left:10%; top:10%; bottom:10%;z-index:520;opacity:0;-webkit-border-radius:50px;"></div>

</body>
</html>


